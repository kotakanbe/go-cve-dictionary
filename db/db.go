package db

import (
	"fmt"
	"strings"

	version "github.com/hashicorp/go-version"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"
	"golang.org/x/xerrors"

	"github.com/knqyf263/go-cpe/common"
	"github.com/knqyf263/go-cpe/matching"
	"github.com/knqyf263/go-cpe/naming"
)

// DB is interface for a database driver
type DB interface {
	Name() string
	CloseDB() error
	Get(string) (*models.CveDetail, error)
	GetMulti([]string) (map[string]models.CveDetail, error)
	GetCveIDsByCpeURI(string) ([]string, []string, error)
	GetByCpeURI(string) ([]models.CveDetail, error)
	InsertJvn([]models.CveDetail) error
	InsertNvdJSON([]models.CveDetail) error
	CountNvd() (int, error)
	UpsertFeedHash(models.FeedMeta) error
	GetFetchedFeedMeta(string) (*models.FeedMeta, error)
	GetFetchedFeedMetas() ([]models.FeedMeta, error)
}

// NewDB return DB accessor.
func NewDB(dbType, dbpath string, debugSQL bool) (DB, bool, error) {
	switch dbType {
	case dialectSqlite3, dialectMysql, dialectPostgreSQL:
		return NewRDB(dbType, dbpath, debugSQL)
	case dialectRedis:
		return NewRedis(dbType, dbpath, debugSQL)
	}
	return nil, false, fmt.Errorf("Invalid database dialect, %s", dbType)
}

func chunkSlice(l []models.CveDetail, n int) chan []models.CveDetail {
	ch := make(chan []models.CveDetail)

	go func() {
		for i := 0; i < len(l); i += n {
			fromIdx := i
			toIdx := i + n
			if toIdx > len(l) {
				toIdx = len(l)
			}
			ch <- l[fromIdx:toIdx]
		}
		close(ch)
	}()
	return ch
}

func parseCpeURI(cpe22uri string) (*models.CpeBase, error) {
	wfn, err := naming.UnbindURI(cpe22uri)
	if err != nil {
		return nil, err
	}

	return &models.CpeBase{
		URI:             naming.BindToURI(wfn),
		FormattedString: naming.BindToFS(wfn),
		WellFormedName:  wfn.String(),
		CpeWFN: models.CpeWFN{
			Part:            fmt.Sprintf("%s", wfn.Get(common.AttributePart)),
			Vendor:          fmt.Sprintf("%s", wfn.Get(common.AttributeVendor)),
			Product:         fmt.Sprintf("%s", wfn.Get(common.AttributeProduct)),
			Version:         fmt.Sprintf("%s", wfn.Get(common.AttributeVersion)),
			Update:          fmt.Sprintf("%s", wfn.Get(common.AttributeUpdate)),
			Edition:         fmt.Sprintf("%s", wfn.Get(common.AttributeEdition)),
			Language:        fmt.Sprintf("%s", wfn.Get(common.AttributeLanguage)),
			SoftwareEdition: fmt.Sprintf("%s", wfn.Get(common.AttributeSwEdition)),
			TargetSW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetSw)),
			TargetHW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetHw)),
			Other:           fmt.Sprintf("%s", wfn.Get(common.AttributeOther)),
		},
	}, nil
}

func makeVersionConstraint(dict models.Cpe) string {
	constraints := []string{}
	if dict.VersionStartIncluding != "" {
		constraints = append(constraints, ">= "+dict.VersionStartIncluding)
	}
	if dict.VersionStartExcluding != "" {
		constraints = append(constraints, "> "+dict.VersionStartExcluding)
	}
	if dict.VersionEndIncluding != "" {
		constraints = append(constraints, "<= "+dict.VersionEndIncluding)
	}
	if dict.VersionEndExcluding != "" {
		constraints = append(constraints, "< "+dict.VersionEndExcluding)
	}
	return strings.Join(constraints, ", ")
}

func isSamePartVendorProduct(cpeA, cpeB string) (bool, error) {
	a, err := naming.UnbindURI(cpeA)
	if err != nil {
		return false, xerrors.Errorf("Failed to unbind. CPE: %s. err: %w", cpeA, err)
	}

	b, err := naming.UnbindURI(cpeB)
	if err != nil {
		return false, xerrors.Errorf("Failed to unbind. CPE: %s. err: %w", cpeB, err)
	}

	if a.Get("part") == b.Get("part") &&
		a.Get("vendor") == b.Get("vendor") &&
		a.Get("product") == b.Get("product") {
		return true, nil
	}
	return false, nil
}

func match(specifiedURI string, cpeInNvd models.Cpe) (bool, error) {
	specified, err := naming.UnbindURI(specifiedURI)
	if err != nil {
		return false, xerrors.Errorf("Failed to unbind. CPE: %s. err: %w", specifiedURI, err)
	}

	cpeInNvdWfn, err := naming.UnbindURI(cpeInNvd.URI)
	if err != nil {
		return false, xerrors.Errorf("Failed to unbind. CPE: %s. err: %w", cpeInNvd.URI, err)
	}

	if cpeInNvdWfn.Get("part") != specified.Get("part") ||
		cpeInNvdWfn.Get("vendor") != specified.Get("vendor") ||
		cpeInNvdWfn.Get("product") != specified.Get("product") {
		return false, nil
	}

	if matching.IsEqual(specified, cpeInNvdWfn) {
		log.Debugf("%s equals %s", specified.String(), cpeInNvd.URI)
		return true, nil
	}
	specifiedVer := fmt.Sprintf("%s", specified.Get(common.AttributeVersion))

	switch specifiedVer {
	case "NA", "ANY":
		if err := cpeInNvdWfn.Set(common.AttributeVersion, nil); err != nil {
			return false, err
		}
		return isSuperORSubset(cpeInNvdWfn, specified), nil
	default:
		constraintStr := makeVersionConstraint(cpeInNvd)
		if constraintStr != "" {
			constraints, err := version.NewConstraint(constraintStr)
			if err != nil {
				return false, err
			}
			specifiedVer = strings.Replace(specifiedVer, `\`, "", -1)
			v, err := version.NewVersion(specifiedVer)
			if err != nil {
				log.Debugf("Failed to parse the semver: %s, err: %s", specifiedVer, err)
				return false, err
			}
			if !constraints.Check(v) {
				return false, nil
			}
			log.Debugf("%s satisfies version constraints %s", v, constraintStr)

			if err := cpeInNvdWfn.Set(common.AttributeVersion, nil); err != nil {
				return false, err
			}
			if err := specified.Set(common.AttributeVersion, nil); err != nil {
				return false, err
			}
			return isSuperORSubset(cpeInNvdWfn, specified), nil
		}

		// If the specified version is not as a range, but as a fixed value
		//
		// return true in this case:
		// - config.toml:  	"cpe:/a:apache:cordova:5.1.1::~~~iphone_os~~",
		// - AffectedCPEInNVD:    "cpe:/a:apache:cordova:5.1.1",
		//
		// In this case, target_sw does not match and returns false
		// - config.toml:  	"cpe:/a:apache:cordova:5.1.1::~~~iphone_os~~",
		// - AffectedCPEInNVD:    "cpe:/a:apache:cordova:5.1.1::~~~android~~",
		if fmt.Sprintf("%s", specified.Get(common.AttributeVersion)) !=
			fmt.Sprintf("%s", cpeInNvdWfn.Get(common.AttributeVersion)) {
			return false, nil
		}
		if err := cpeInNvdWfn.Set(common.AttributeVersion, nil); err != nil {
			return false, err
		}
		if err := specified.Set(common.AttributeVersion, nil); err != nil {
			return false, err
		}
		return isSuperORSubset(cpeInNvdWfn, specified), nil
	}
}

func matchCpe(uri string, cve *models.CveDetail) (nvdMatch, jvnMatch bool, err error) {
	nvdCpes := []models.Cpe{}
	if cve.NvdJSON != nil {
		nvdCpes = append(nvdCpes, cve.NvdJSON.Cpes...)
	}
	for _, cpe := range nvdCpes {
		match, err := match(uri, cpe)
		if err != nil {
			log.Debugf("Failed to match: %s", err)

			// Try to exact match by vendor, product and version if the version in CPE is not a semVer style.
			ok, err := matchExactByAffects(uri, cve.NvdJSON.Affects)
			if err != nil {
				return false, false, err
			}
			if ok {
				return true, false, nil
			}
			continue
		} else if match {
			return true, false, nil
		}
	}

	// CPE that exists only in JVN is also detected.
	// There is a possibility of false positives since the JVN does not contain version information.
	if cve.Jvn == nil {
		return false, false, nil
	}

	for _, cpe := range cve.Jvn.Cpes {
		// If NVD has data of the same `type`, `verndor`, and `product`, NVD is used in priority.
		// Because NVD has version information, but JVN does not.
		found := false
		for _, nvdCpe := range nvdCpes {
			ok, err := isSamePartVendorProduct(nvdCpe.URI, cpe.URI)
			if err != nil {
				continue
			}
			if ok {
				found = true
				break
			}
		}
		if found {
			continue
		}

		ok, err := isSamePartVendorProduct(uri, cpe.URI)
		if err != nil {
			continue
		}
		if ok {
			return false, true, nil
		}
	}
	return false, false, nil
}

func isSuperORSubset(source, target common.WellFormedName) bool {
	if matching.IsSuperset(source, target) {
		log.Debugf("%s is superset of %s", source.String(), target.String())
		return true
	}
	if matching.IsSubset(source, target) {
		log.Debugf("%s is subset of %s", source.String(), target.String())
		return true
	}
	return false
}

func matchExactByAffects(uri string, affects []models.Affect) (bool, error) {
	wfn, err := naming.UnbindURI(uri)
	if err != nil {
		return false, err
	}
	var vendor, product, ver string
	var ok bool
	if vendor, ok = wfn.Get("vendor").(string); !ok {
		log.Errorf("Failed to assert vendor. cpe uri: %s", uri)
		return false, nil
	}
	if product, ok = wfn.Get("product").(string); !ok {
		log.Errorf("Failed to assert product. cpe uri: %s", uri)
		return false, nil
	}
	if ver, ok = wfn.Get("version").(string); !ok {
		log.Errorf("Failed to assert version. cpe uri: %s", uri)
		return false, nil
	}

	for _, a := range affects {
		if trimBSlash(a.Vendor) == trimBSlash(vendor) &&
			trimBSlash(a.Product) == trimBSlash(product) &&
			trimBSlash(a.Version) == trimBSlash(ver) {
			return true, nil
		}
	}
	return false, nil
}

func trimBSlash(s string) string {
	return strings.Replace(s, `\`, "", -1)
}
