package db

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"reflect"
	"strconv"
	"time"

	"github.com/cheggaaa/pb"
	"github.com/go-redis/redis"
	"github.com/kotakanbe/go-cve-dictionary/jvn"
	log "github.com/kotakanbe/go-cve-dictionary/log"
	"github.com/kotakanbe/go-cve-dictionary/models"
	"github.com/kotakanbe/go-cve-dictionary/nvd"
)

/**
# Redis Data Structure

- HASH
  ┌───┬────────────┬──────────┬──────────┬─────────────────────────────────┐
  │NO │    HASH    │  FIELD   │  VALUE   │             PURPOSE             │
  └───┴────────────┴──────────┴──────────┴─────────────────────────────────┘
  ┌───┬────────────┬──────────┬──────────┬─────────────────────────────────┐
  │ 1 │ CVE#$CVEID │NVD or JVN│ $CVEJSON │     TO GET CVEJSON BY CVEID     │
  ├───┼────────────┼──────────┼──────────┼─────────────────────────────────┤
  │ 2 │  CVE#CPE   │ $CPENAME │ $CPEJSON │    TO GET CPEJSON BY CPENAME    │
  └───┴────────────┴──────────┴──────────┴─────────────────────────────────┘

- ZINDE  X
  ┌───┬────────────┬──────────┬──────────┬─────────────────────────────────┐
  │NO │    KEY     │  SCORE   │  MEMBER  │             PURPOSE             │
  └───┴────────────┴──────────┴──────────┴─────────────────────────────────┘
  ┌───┬────────────┬──────────┬──────────┬─────────────────────────────────┐
  │ 3 │CVE#$CPENAME│    0     │  $CVEID  │TO GET RELATED []CVEID BY CPENAME│
  ├───┼────────────┼──────────┼──────────┼─────────────────────────────────┤
  │ 4 │CVE#CPENAME │    0     │ $CPENAME │   TO GET ALL CPENAME QUICKLY    │
  └───┴────────────┴──────────┴──────────┴─────────────────────────────────┘
**/

const (
	dialectRedis  = "redis"
	hashKeyPrefix = "CVE#"
)

// RedisDriver is Driver for Redis
type RedisDriver struct {
	name string
	conn *redis.Client
}

// Name return db name
func (r *RedisDriver) Name() string {
	return r.name
}

// OpenDB opens Database
func (r *RedisDriver) OpenDB(dbType, dbPath string, debugSQL bool) (err error) {
	if err = r.connectRedis(dbPath); err != nil {
		err = fmt.Errorf("Failed to open DB. dbtype: %s, dbpath: %s, err: %s", dbType, dbPath, err)
	}
	return
}

func (r *RedisDriver) connectRedis(dbPath string) error {
	var err error
	var option *redis.Options
	if option, err = redis.ParseURL(dbPath); err != nil {
		log.Error(err)
		return err
	}
	r.conn = redis.NewClient(option)
	if err = r.conn.Ping().Err(); err != nil {
		return err
	}
	return nil
}

// MigrateDB migrates Database
func (r *RedisDriver) MigrateDB() error {
	return nil
}

// Get Select Cve information from DB.
func (r *RedisDriver) Get(cveID string) *models.CveDetail {
	// Avoid null slice being null in JSON
	emptyCveDetail := models.CveDetail{
		Nvd: models.Nvd{
			References: []models.Reference{},
			Cpes:       []models.Cpe{},
		},
		Jvn: models.Jvn{
			References: []models.Reference{},
			Cpes:       []models.Cpe{},
		},
	}

	var result *redis.StringStringMapCmd
	if result = r.conn.HGetAll(hashKeyPrefix + cveID); result.Err() != nil {
		log.Error(result.Err())
		return &emptyCveDetail
	}

	jvn := models.Jvn{
		References: []models.Reference{},
		Cpes:       []models.Cpe{},
	}

	var err error
	if j, ok := result.Val()["Jvn"]; ok {
		if err = json.Unmarshal([]byte(j), &jvn); err != nil {
			log.Errorf("Failed to Unmarshal json. err : %s", err)
			return &emptyCveDetail
		}
	}

	nvd := models.Nvd{
		References: []models.Reference{},
		Cpes:       []models.Cpe{},
	}
	if j, ok := result.Val()["Nvd"]; ok {
		if err = json.Unmarshal([]byte(j), &nvd); err != nil {
			log.Errorf("Failed to Unmarshal json. err : %s", err)
			return &emptyCveDetail
		}
	}

	cveDetail := &models.CveDetail{
		CveID: cveID,
		Nvd:   nvd,
		Jvn:   jvn,
	}

	return cveDetail
}

// GetByCpeName Select Cve information from DB.
func (r *RedisDriver) GetByCpeName(cpeName string) (details []*models.CveDetail) {
	var result *redis.StringSliceCmd
	if result = r.conn.ZRange(hashKeyPrefix+cpeName, 0, -1); result.Err() != nil {
		log.Error(result.Err())
		return details
	}

	for _, v := range result.Val() {
		details = append(details, r.Get(v))
	}
	return
}

// InsertJvn insert items fetched from JVN.
func (r *RedisDriver) InsertJvn(items []jvn.Item, debugDiff bool) error {
	log.Info("Inserting fetched CVEs...")

	cves := convertJvn(items)
	if debugDiff {
		if err := r.getJvnDiff(cves); err != nil {
			log.Warnf("Failed to create jvn diff. err : %s.", err)
		}
	}
	if err := r.insertIntoJvn(cves); err != nil {
		return err
	}
	return nil
}

// InsertIntoJvn inserts Cve Information into DB
func (r *RedisDriver) insertIntoJvn(cves []models.CveDetail) error {
	var err error
	var refreshedJvns []string
	bar := pb.StartNew(len(cves))

	for chunked := range chunkSlice(cves, 10) {
		var pipe redis.Pipeliner
		pipe = r.conn.Pipeline()
		for _, c := range chunked {
			bar.Increment()

			var jj []byte
			if jj, err = json.Marshal(c.Jvn); err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}
			refreshedJvns = append(refreshedJvns, c.CveID)
			if result := pipe.HSet(c.CveID, "Jvn", string(jj)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
			}

			for _, cpe := range c.Jvn.Cpes {
				var jc []byte
				if jc, err = json.Marshal(cpe); err != nil {
					return fmt.Errorf("Failed to marshal json. err: %s", err)
				}

				if result := pipe.HSet(hashKeyPrefix+"Cpe", cpe.CpeName, jc); result.Err() != nil {
					return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
				}
				if result := pipe.ZAdd(hashKeyPrefix+cpe.CpeName, redis.Z{0, c.CveID}); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe name. err: %s", result.Err())
				}
				if result := pipe.ZAdd(hashKeyPrefix+"CpeName", redis.Z{0, cpe.CpeName}); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
				}
			}
		}
		if _, err = pipe.Exec(); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
	}
	bar.Finish()
	log.Infof("Refreshed %d Jvns.", len(refreshedJvns))
	//  log.Debugf("%v", refreshedJvns)
	return nil
}

// CountNvd count nvd table
func (r *RedisDriver) CountNvd() (int, error) {
	var result *redis.StringSliceCmd
	if result = r.conn.Keys(hashKeyPrefix + "CVE*"); result.Err() != nil {
		return 0, result.Err()
	}
	return len(result.Val()), nil
}

// InsertNvd inserts CveInformation into DB
func (r *RedisDriver) InsertNvd(entries []nvd.Entry, debugDiff bool) error {
	log.Info("Inserting CVEs...")

	cves := convertNvd(entries)
	if debugDiff {
		if err := r.getNvdDiff(cves); err != nil {
			log.Warnf("Failed to create nvd diff. err : %s.", err)
		}
	}
	if err := r.insertIntoNvd(cves); err != nil {
		return err
	}
	return nil
}

// insertIntoNvd inserts CveInformation into DB
func (r *RedisDriver) insertIntoNvd(cves []models.CveDetail) error {
	var err error
	var refreshedNvds []string
	bar := pb.StartNew(len(cves))

	for chunked := range chunkSlice(cves, 10) {
		var pipe redis.Pipeliner
		pipe = r.conn.Pipeline()
		for _, c := range chunked {
			bar.Increment()

			var jn []byte
			if jn, err = json.Marshal(c.Nvd); err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}
			refreshedNvds = append(refreshedNvds, c.CveID)
			if result := pipe.HSet(hashKeyPrefix+c.CveID, "Nvd", string(jn)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
			}

			for _, cpe := range c.Nvd.Cpes {
				var jc []byte
				if jc, err = json.Marshal(cpe); err != nil {
					return fmt.Errorf("Failed to marshal json. err: %s", err)
				}

				if result := pipe.HSet(hashKeyPrefix+"Cpe", cpe.CpeName, jc); result.Err() != nil {
					return fmt.Errorf("Failed to HSet cpe. err: %s", result.Err())
				}
				if result := pipe.ZAdd(hashKeyPrefix+cpe.CpeName, redis.Z{0, c.CveID}); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe name. err: %s", result.Err())
				}
				if result := pipe.ZAdd(hashKeyPrefix+"CpeName", redis.Z{0, cpe.CpeName}); result.Err() != nil {
					return fmt.Errorf("Failed to ZAdd cpe. err: %s", result.Err())
				}
			}
		}
		if _, err = pipe.Exec(); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
	}
	bar.Finish()

	log.Infof("Refreshed %d Nvds.", len(refreshedNvds))
	//  log.Debugf("%v", refreshedNvds)
	return nil
}

// CveDiff is the defference of CVE
type CveDiff struct {
	CveID            string
	Field            string
	OldValue         string
	NewValue         string
	LastModifiedDate time.Time
}

func (r *RedisDriver) getJvnDiff(cves []models.CveDetail) (err error) {
	var cveDiffs []*CveDiff
	for _, cve := range cves {
		var oldJvn models.Jvn
		result := r.conn.HGet(hashKeyPrefix+cve.Jvn.CveID, "Jvn")
		if result.Val() == "" {
			continue
		}

		if err = json.Unmarshal([]byte(result.Val()), &oldJvn); err != nil {
			log.Errorf("Failed to Unmarshal json. err : %s", err)
			return err
		}
		if oldJvn.LastModifiedDate.Equal(cve.Jvn.LastModifiedDate) {
			continue
		}
		if ok, cveDiff := getDiff(oldJvn.Title, cve.Jvn.Title); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "Title"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldJvn.Summary, cve.Jvn.Summary); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "Summary"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldJvn.JvnLink, cve.Jvn.JvnLink); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "JvnLink"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldJvn.JvnID, cve.Jvn.JvnID); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "JvnID"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		oldScoreStr := strconv.FormatFloat(oldJvn.Score, 'f', -1, 64)
		newScoreStr := strconv.FormatFloat(cve.Jvn.Score, 'f', -1, 64)
		if ok, cveDiff := getDiff(oldScoreStr, newScoreStr); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "Score"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldJvn.Severity, cve.Jvn.Severity); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "Severity"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldJvn.Vector, cve.Jvn.Vector); ok {
			cveDiff.CveID = cve.Jvn.CveID
			cveDiff.Field = "Vector"
			cveDiff.LastModifiedDate = cve.Jvn.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if !reflect.DeepEqual(oldJvn.References, cve.Jvn.References) {
			cveDiff := &CveDiff{
				CveID:            cve.Jvn.CveID,
				Field:            "References",
				OldValue:         oldJvn.JvnLink,
				NewValue:         cve.Jvn.JvnLink,
				LastModifiedDate: cve.Jvn.LastModifiedDate,
			}
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if !reflect.DeepEqual(oldJvn.Cpes, cve.Jvn.Cpes) {
			cveDiff := &CveDiff{
				CveID:            cve.Jvn.CveID,
				Field:            "Cpes",
				OldValue:         oldJvn.JvnLink,
				NewValue:         cve.Jvn.JvnLink,
				LastModifiedDate: cve.Jvn.LastModifiedDate,
			}
			cveDiffs = append(cveDiffs, cveDiff)
		}
	}
	if 0 < len(cveDiffs) {
		var cveDiffJSON []byte
		if cveDiffJSON, err = json.Marshal(cveDiffs); err != nil {
			log.Errorf("Failed to marshal diff. err: %s", err)
		}
		if err = ioutil.WriteFile("JvnDiff.json", cveDiffJSON, 0644); err != nil {
			log.Errorf("Failed to write jvn diff json. err: %s", err)
		}
	}
	log.Infof("%s Diffs", strconv.Itoa(len(cveDiffs)))
	return err
}

func (r *RedisDriver) getNvdDiff(cves []models.CveDetail) (err error) {
	var cveDiffs []*CveDiff
	for _, cve := range cves {
		var oldNvd models.Nvd
		nvdLink := "https://nvd.nist.gov/vuln/detail/"
		result := r.conn.HGet(hashKeyPrefix+cve.Nvd.CveID, "Nvd")
		if result.Val() == "" {
			continue
		}

		if err = json.Unmarshal([]byte(result.Val()), &oldNvd); err != nil {
			log.Errorf("Failed to Unmarshal json. err : %s", err)
			return err
		}

		if oldNvd.LastModifiedDate.Equal(cve.Nvd.LastModifiedDate) {
			continue
		}

		if ok, cveDiff := getDiff(oldNvd.Summary, cve.Nvd.Summary); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "Summary"
			cveDiffs = append(cveDiffs, cveDiff)
		}
		oldScoreStr := strconv.FormatFloat(oldNvd.Score, 'f', -1, 64)
		newScoreStr := strconv.FormatFloat(cve.Nvd.Score, 'f', -1, 64)
		if ok, cveDiff := getDiff(oldScoreStr, newScoreStr); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "Score"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.AccessVector, cve.Nvd.AccessVector); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "AccessVector"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.AccessComplexity, cve.Nvd.AccessComplexity); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "AccessComplexity"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.Authentication, cve.Nvd.Authentication); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "Authentication"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.ConfidentialityImpact, cve.Nvd.ConfidentialityImpact); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "ConfidentialityImpact"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.AvailabilityImpact, cve.Nvd.AvailabilityImpact); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "AvailabilityImpact"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if ok, cveDiff := getDiff(oldNvd.CweID, cve.Nvd.CweID); ok {
			cveDiff.CveID = cve.Nvd.CveID
			cveDiff.Field = "CweID"
			cveDiff.LastModifiedDate = cve.Nvd.LastModifiedDate
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if !reflect.DeepEqual(oldNvd.References, cve.Nvd.References) {
			cveDiff := &CveDiff{
				CveID:            cve.Nvd.CveID,
				Field:            "References",
				OldValue:         filepath.Join(nvdLink, cve.Nvd.CveID),
				NewValue:         filepath.Join(nvdLink, cve.Nvd.CveID),
				LastModifiedDate: cve.Nvd.LastModifiedDate,
			}
			cveDiffs = append(cveDiffs, cveDiff)
		}
		if !reflect.DeepEqual(oldNvd.Cpes, cve.Nvd.Cpes) {
			cveDiff := &CveDiff{
				CveID:            cve.Nvd.CveID,
				Field:            "Cpes",
				OldValue:         filepath.Join(nvdLink, cve.Nvd.CveID),
				NewValue:         filepath.Join(nvdLink, cve.Nvd.CveID),
				LastModifiedDate: cve.Nvd.LastModifiedDate,
			}
			cveDiffs = append(cveDiffs, cveDiff)
		}
	}
	if 0 < len(cveDiffs) {
		var cveDiffJSON []byte
		if cveDiffJSON, err = json.Marshal(cveDiffs); err != nil {
			log.Errorf("Failed to marshal diff. err: %s", err)
		}
		if err = ioutil.WriteFile("NvdDiff.json", cveDiffJSON, 0644); err != nil {
			log.Errorf("Failed to write nvd diff json. err: %s", err)
		}
	}
	log.Infof("%s Diffs", strconv.Itoa(len(cveDiffs)))
	return err
}

func getDiff(oldValue, newValue string) (bool, *CveDiff) {
	if oldValue == newValue {
		return false, nil
	}

	return true, &CveDiff{
		OldValue: oldValue,
		NewValue: newValue,
	}
}
