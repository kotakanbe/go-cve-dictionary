package db

import (
	"reflect"
	"testing"

	_ "github.com/jinzhu/gorm/dialects/mysql"
	_ "github.com/jinzhu/gorm/dialects/postgres"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"github.com/kotakanbe/go-cve-dictionary/models"
)

func TestRDBDriver_getMatchingCpes(t *testing.T) {
	nvdRangeCpe := models.Cpe{
		NvdJSONID: 1,
		CpeBase: models.CpeBase{
			URI: "cpe:/o:qualcomm:qcs605_firmware",
			CpeWFN: models.CpeWFN{
				Part:    "o",
				Vendor:  "qualcomm",
				Product: "qcs605_firmware",
			},
			VersionStartIncluding: "0.0.1",
			VersionEndIncluding:   "2.0.0",
		},
	}
	nvdNonSemVerCpe := models.Cpe{
		NvdJSONID: 1,
		CpeBase: models.CpeBase{
			URI: "cpe:/o:qualcomm:qcs605_firmware",
			CpeWFN: models.CpeWFN{
				Part:    "o",
				Vendor:  "qualcomm",
				Product: "qcs605_firmware",
			},
			VersionStartIncluding: "hoge",
			VersionEndIncluding:   "hoge",
		},
	}
	jvnCpe := models.Cpe{
		JvnID: 1,
		CpeBase: models.CpeBase{
			URI: "cpe:/o:qualcomm:qcs605_firmware",
			CpeWFN: models.CpeWFN{
				Part:    "o",
				Vendor:  "qualcomm",
				Product: "qcs605_firmware",
			},
		},
	}

	type args struct {
		uri                        string
		getCpesByVendorProductFunc func(string) ([]models.Cpe, error)
		getAffects                 func(uint) ([]models.Affect, error)
	}
	tests := []struct {
		name    string
		args    args
		want    []models.Cpe
		wantErr bool
	}{
		{
			name: "nvd range match",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:1.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdRangeCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) { panic("not implemented") },
			},
			want:    []models.Cpe{nvdRangeCpe},
			wantErr: false,
		},
		{
			name: "nvd range not match",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:3.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdRangeCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) { panic("not implemented") },
			},
			want:    []models.Cpe{},
			wantErr: false,
		},
		{
			name: "nvd affects match",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:1.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdNonSemVerCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) {
					return []models.Affect{
						{
							NvdJSONID: 1,
							Vendor:    "qualcomm",
							Product:   "qcs605_firmware",
							Version:   "1.0.0",
						},
					}, nil
				},
			},
			want:    []models.Cpe{nvdNonSemVerCpe},
			wantErr: false,
		},
		{
			name: "nvd affects not match",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:1.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdNonSemVerCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) {
					return []models.Affect{
						{
							NvdJSONID: 1,
							Vendor:    "qualcomm",
							Product:   "qcs605_firmware",
							Version:   "1.0.1",
						},
					}, nil
				},
			},
			want:    []models.Cpe{},
			wantErr: false,
		},
		{
			name: "jvn match",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:1.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{jvnCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) {
					return nil, nil
				},
			},
			want:    []models.Cpe{jvnCpe},
			wantErr: false,
		},
		{
			name: "NVD has priority over JVN",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:3.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdRangeCpe, jvnCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) {
					return nil, nil
				},
			},
			want:    []models.Cpe{},
			wantErr: false,
		},
		{
			name: "NVD has priority over JVN",
			args: args{
				uri: "cpe:/o:qualcomm:qcs605_firmware:1.0.0",
				getCpesByVendorProductFunc: func(string) ([]models.Cpe, error) {
					return []models.Cpe{nvdRangeCpe, jvnCpe}, nil
				},
				getAffects: func(uint) ([]models.Affect, error) {
					return nil, nil
				},
			},
			want:    []models.Cpe{nvdRangeCpe},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &RDBDriver{}
			got, err := r.getMatchingCpes(tt.args.uri, tt.args.getCpesByVendorProductFunc, tt.args.getAffects)
			if (err != nil) != tt.wantErr {
				t.Errorf("RDBDriver.getMatchingCpes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RDBDriver.getMatchingCpes() = %v, want %v", got, tt.want)
			}
		})
	}
}
