package mitre

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"golang.org/x/xerrors"

	"github.com/vulsio/go-cve-dictionary/fetcher"
	"github.com/vulsio/go-cve-dictionary/log"
	"github.com/vulsio/go-cve-dictionary/models"
	"github.com/vulsio/go-cve-dictionary/util"
)

const repositoryURL = "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.tar.gz"

func Fetch() (string, error) {
	d := util.CacheDir()

	if err := os.RemoveAll(d); err != nil {
		return "", xerrors.Errorf("Failed to remove %s. err: %w", d, err)
	}

	bs, err := fetcher.FetchFeedFile(repositoryURL, false)
	if err != nil {
		return "", xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	gr, err := gzip.NewReader(bytes.NewReader(bs))
	if err != nil {
		return "", xerrors.Errorf("Failed to create gzip reader. err: %w", err)
	}
	defer gr.Close()

	tr := tar.NewReader(gr)
	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return "", xerrors.Errorf("Failed to next tar reader. err: %w", err)
		}

		if hdr.FileInfo().IsDir() {
			continue
		}

		if !strings.HasPrefix(filepath.Base(hdr.Name), "CVE-") {
			continue
		}

		if err := func() error {
			ss := strings.Split(filepath.Base(hdr.Name), "-")
			if len(ss) != 3 {
				return xerrors.Errorf("Failed to parse year. err: invalid ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}.json", filepath.Base(hdr.Name))
			}
			if _, err := time.Parse("2006", ss[1]); err != nil {
				return xerrors.Errorf("Failed to parse year. err: invalid ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}.json", filepath.Base(hdr.Name))
			}

			if err := os.MkdirAll(filepath.Join(d, ss[1]), os.ModePerm); err != nil {
				return xerrors.Errorf("Failed to mkdir %s. err: %w", filepath.Join(d, ss[1]), err)
			}

			f, err := os.Create(filepath.Join(d, ss[1], filepath.Base(hdr.Name)))
			if err != nil {
				return xerrors.Errorf("Failed to create %s. err: %w", filepath.Join(d, ss[1], filepath.Base(hdr.Name)), err)
			}
			defer f.Close()

			if _, err := io.Copy(f, tr); err != nil {
				return xerrors.Errorf("Failed to copy %s to %s. err: %w", hdr.Name, filepath.Join(d, ss[1], filepath.Base(hdr.Name)), err)
			}

			return nil
		}(); err != nil {
			return "", xerrors.Errorf("Failed to extract %s. err: %w", hdr.Name, err)
		}
	}

	return d, nil
}

// Convert convert <cacheDir>/<year>/CVE-<year>-\d{4,}.json to []models.Mitre
func Convert(cacheDir, year string) ([]models.Mitre, error) {
	var ps []string
	if err := filepath.WalkDir(filepath.Join(cacheDir, year), func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		ps = append(ps, path)
		return nil
	}); err != nil {
		return nil, xerrors.Errorf("Failed to walk %s. err: %w", filepath.Join(cacheDir, year), err)
	}

	reqChan := make(chan string, len(ps))
	resChan := make(chan *models.Mitre, len(ps))
	errChan := make(chan error, len(ps))
	defer close(reqChan)
	defer close(resChan)
	defer close(errChan)

	go func() {
		for _, p := range ps {
			reqChan <- p
		}
	}()

	concurrency := runtime.NumCPU() + 2
	tasks := util.GenWorkers(concurrency)
	for range ps {
		tasks <- func() {
			req := <-reqChan
			cve, err := convertToModel(req)
			if err != nil {
				errChan <- err
				return
			}
			resChan <- cve
		}
	}

	cves := []models.Mitre{}
	errs := []error{}
	timeout := time.After(10 * 60 * time.Second)
	for range ps {
		select {
		case res := <-resChan:
			if res != nil {
				cves = append(cves, *res)
			}
		case err := <-errChan:
			errs = append(errs, err)
		case <-timeout:
			return nil, fmt.Errorf("Timeout Fetching")
		}
	}
	if 0 < len(errs) {
		return nil, xerrors.Errorf("%w", errs)
	}
	return cves, nil
}

// convertToModel converts Mitre JSON to model structure.
func convertToModel(cvePath string) (*models.Mitre, error) {
	f, err := os.Open(cvePath)
	if err != nil {
		return nil, xerrors.Errorf("Failed to open %s. err: %w", cvePath, err)
	}
	defer f.Close()

	var item cve
	if err := json.NewDecoder(f).Decode(&item); err != nil {
		return nil, xerrors.Errorf("Failed to decode %s. err: %w", cvePath, err)
	}

	if item.CVEMetadata.State == "REJECTED" {
		return nil, nil
	}

	return &models.Mitre{
		DataType:    item.DataType,
		DataVersion: item.DataVersion,
		CVEMetadata: models.MitreCVEMetadata{
			CVEID:             item.CVEMetadata.CVEID,
			AssignerOrgID:     item.CVEMetadata.AssignerOrgID,
			AssignerShortName: item.CVEMetadata.AssignerShortName,
			RequesterUserID:   item.CVEMetadata.RequesterUserID,
			Serial:            item.CVEMetadata.Serial,
			State:             item.CVEMetadata.State,
			DatePublished:     parseTime(layouts, item.CVEMetadata.DatePublished),
			DateUpdated:       parseTime(layouts, item.CVEMetadata.DateUpdated),
			DateReserved:      parseTime(layouts, item.CVEMetadata.DateReserved),
		},
		Containers: convertContainers(item.Containers.CNA, item.Containers.ADP),
	}, nil
}

var layouts = []string{"2006-01-02", "2006-01-02T15:04:05", "2006-01-02T15:04:05Z", "2006-01-02T15:04:05.000Z", "2006-01-02T15:04:05.000-07:00", "2006-01-02T15:04:05.000000", "2006-01-02T15:04:05.000000Z", "2006-01-02T15:04:05-07:00"}

func parseTime(layouts []string, value *string) *time.Time {
	if value == nil || *value == "" {
		return nil
	}
	for _, l := range layouts {
		t, err := time.Parse(l, *value)
		if err == nil {
			return &t
		}
	}
	log.Warnf("no layout to adapt to %q", *value)
	return nil
}

func convertContainers(cna cna, adps []adp) []models.MitreContainer {
	cs := make([]models.MitreContainer, 0, 1+len(adps))
	cs = append(cs, models.MitreContainer{
		ContainerType: "CNA",
		ProviderMetadata: models.MitreProviderMetadata{
			OrgID:       cna.ProviderMetadata.OrgID,
			ShortName:   cna.ProviderMetadata.ShortName,
			DateUpdated: parseTime(layouts, cna.ProviderMetadata.DateUpdated),
		},
		Title:            cna.Title,
		Descriptions:     convertDescription(cna.Descriptions),
		Affected:         convertAffected(cna.Affected),
		ProblemTypes:     convertProblemType(cna.ProblemTypes),
		Impacts:          convertImpact(cna.Impacts),
		Metrics:          convertMetric(cna.Metrics),
		Workarounds:      convertWorkaround(cna.Workarounds),
		Solutions:        convertSolution(cna.Solutions),
		Exploits:         convertExploit(cna.Exploits),
		Configurations:   convertConfiguration(cna.Configurations),
		References:       covnertReference(cna.References),
		Timeline:         convertTimeline(cna.Timeline),
		Credits:          convertCredit(cna.Credits),
		Source:           string(cna.Source),
		Tags:             convertTag(cna.Tags),
		TaxonomyMappings: convertTaxonomyMappings(cna.TaxonomyMappings),
		DateAssigned:     parseTime(layouts, cna.DateAssigned),
		DatePublic:       parseTime(layouts, cna.DatePublic),
	})
	for _, adp := range adps {
		cs = append(cs, models.MitreContainer{
			ContainerType: "ADP",
			ProviderMetadata: models.MitreProviderMetadata{
				OrgID:       adp.ProviderMetadata.OrgID,
				ShortName:   adp.ProviderMetadata.ShortName,
				DateUpdated: parseTime(layouts, adp.ProviderMetadata.DateUpdated),
			},
			Title:            adp.Title,
			Descriptions:     convertDescription(adp.Descriptions),
			Affected:         convertAffected(adp.Affected),
			ProblemTypes:     convertProblemType(adp.ProblemTypes),
			Impacts:          convertImpact(adp.Impacts),
			Metrics:          convertMetric(adp.Metrics),
			Workarounds:      convertWorkaround(adp.Workarounds),
			Solutions:        convertSolution(adp.Solutions),
			Exploits:         convertExploit(adp.Exploits),
			Configurations:   convertConfiguration(adp.Configurations),
			References:       covnertReference(adp.References),
			Timeline:         convertTimeline(adp.Timeline),
			Credits:          convertCredit(adp.Credits),
			Source:           string(adp.Source),
			Tags:             convertTag(adp.Tags),
			TaxonomyMappings: convertTaxonomyMappings(adp.TaxonomyMappings),
			DatePublic:       parseTime(layouts, adp.DatePublic),
		})
	}
	return cs
}

func convertDescription(descriptions []description) []models.MitreDescription {
	ds := make([]models.MitreDescription, 0, len(descriptions))
	for _, d := range descriptions {
		ms := make([]models.MitreDescriptionSupportingMedia, 0, len(d.SupportingMedia))
		for _, m := range d.SupportingMedia {
			ms = append(ms, models.MitreDescriptionSupportingMedia{
				Type:   m.Type,
				Base64: m.Base64,
				Value:  m.Value,
			})
		}
		ds = append(ds, models.MitreDescription{
			Lang:            d.Lang,
			Value:           d.Value,
			SupportingMedia: ms,
		})
	}
	return ds
}

func convertAffected(affected []product) []models.MitreProduct {
	ps := make([]models.MitreProduct, 0, len(affected))
	for _, p := range affected {
		cs := make([]models.MitreProductCPE, 0, len(p.Cpes))
		for _, c := range p.Cpes {
			cs = append(cs, models.MitreProductCPE{
				CPE: c,
			})
		}

		ms := make([]models.MitreProductModule, 0, len(p.Modules))
		for _, m := range p.Modules {
			ms = append(ms, models.MitreProductModule{
				Module: m,
			})
		}

		pfs := make([]models.MitreProductProgramFile, 0, len(p.ProgramFiles))
		for _, pf := range p.ProgramFiles {
			pfs = append(pfs, models.MitreProductProgramFile{
				ProgramFile: pf,
			})
		}

		prs := make([]models.MitreProductProgramRoutine, 0, len(p.ProgramRoutines))
		for _, pr := range p.ProgramRoutines {
			prs = append(prs, models.MitreProductProgramRoutine{
				Name: pr.Name,
			})
		}

		pls := make([]models.MitreProductPlatform, 0, len(p.Platforms))
		for _, pl := range p.Platforms {
			pls = append(pls, models.MitreProductPlatform{
				Platform: pl,
			})
		}

		vs := make([]models.MitreProductVersion, 0, len(p.Versions))
		for _, v := range p.Versions {
			cs := make([]models.MitreProductVersionChange, 0, len(v.Changes))
			for _, c := range v.Changes {
				cs = append(cs, models.MitreProductVersionChange{
					At:     c.At,
					Status: c.Status,
				})
			}
			vs = append(vs, models.MitreProductVersion{
				Status:          v.Status,
				VersionType:     v.VersionType,
				Version:         v.Version,
				LessThan:        v.LessThan,
				LessThanOrEqual: v.LessThanOrEqual,
				Changes:         cs,
			})
		}

		ps = append(ps, models.MitreProduct{
			Vendor:          p.Vendor,
			Product:         p.Product,
			CollectionURL:   p.CollectionURL,
			PackageName:     p.PackageName,
			Cpes:            cs,
			Modules:         ms,
			ProgramFiles:    pfs,
			ProgramRoutines: prs,
			Platforms:       pls,
			Repo:            p.Repo,
			DefaultStatus:   p.DefaultStatus,
			Versions:        vs,
		})
	}
	return ps
}

func convertProblemType(problemTypes []problemType) []models.MitreProblemType {
	ps := make([]models.MitreProblemType, 0, len(problemTypes))
	for _, p := range problemTypes {
		ds := make([]models.MitreProblemTypeDescription, 0, len(p.Descriptions))
		for _, d := range p.Descriptions {
			rs := make([]models.MitreProblemTypeDescriptionReference, 0, len(d.References))
			for _, r := range d.References {
				rs = append(rs, models.MitreProblemTypeDescriptionReference{
					Reference: models.Reference{
						Link: r.URL,
						Tags: strings.Join(r.Tags, ","),
						Name: func() string {
							if r.Name == nil {
								return ""
							}
							return *r.Name
						}(),
					},
				})
			}
			ds = append(ds, models.MitreProblemTypeDescription{
				Type:        d.Type,
				Lang:        d.Lang,
				Description: d.Description,
				CweID:       d.CweID,
				References:  rs,
			})
		}
		ps = append(ps, models.MitreProblemType{Descriptions: ds})
	}
	return ps
}

func convertImpact(impacts []impact) []models.MitreImpact {
	is := make([]models.MitreImpact, 0, len(impacts))
	for _, i := range impacts {
		ds := make([]models.MitreImpactDescription, 0, len(i.Descriptions))
		for _, d := range i.Descriptions {
			ms := make([]models.MitreImpactDescriptionSupportingMedia, 0, len(d.SupportingMedia))
			for _, m := range d.SupportingMedia {
				ms = append(ms, models.MitreImpactDescriptionSupportingMedia{
					Type:   m.Type,
					Base64: m.Base64,
					Value:  m.Value,
				})
			}
			ds = append(ds, models.MitreImpactDescription{
				Lang:            d.Lang,
				Value:           d.Value,
				SupportingMedia: ms,
			})
		}
		is = append(is, models.MitreImpact{
			Descriptions: ds,
			CapecID:      i.CapecID,
		})
	}
	return is
}

func convertMetric(metrics []metric) []models.MitreMetric {
	var ms []models.MitreMetric
	for _, m := range metrics {
		sc := make([]models.MitreMetricScenario, 0, len(m.Scenarios))
		for _, s := range m.Scenarios {
			sc = append(sc, models.MitreMetricScenario{
				Lang:  s.Lang,
				Value: s.Value,
			})
		}

		if m.CVSSv2 != nil {
			ms = append(ms, models.MitreMetric{
				Format: func() string {
					if m.Format != nil {
						return *m.Format
					}
					return "CVSS"
				}(),
				Scenarios: sc,
				CVSSv2: &models.MitreMetricCVSS2{
					Cvss2: models.Cvss2{
						VectorString: m.CVSSv2.VectorString,
						BaseScore:    m.CVSSv2.BaseScore,
					},
				},
			})
		}
		if m.CVSSv30 != nil {
			ms = append(ms, models.MitreMetric{
				Format: func() string {
					if m.Format != nil {
						return *m.Format
					}
					return "CVSS"
				}(),
				Scenarios: sc,
				CVSSv30: &models.MitreMetricCVSS30{
					Cvss3: models.Cvss3{
						VectorString: m.CVSSv30.VectorString,
						BaseScore:    m.CVSSv30.BaseScore,
						BaseSeverity: m.CVSSv30.BaseSeverity,
					},
				},
			})
		}
		if m.CVSSv31 != nil {
			ms = append(ms, models.MitreMetric{
				Format: func() string {
					if m.Format != nil {
						return *m.Format
					}
					return "CVSS"
				}(),
				Scenarios: sc,
				CVSSv31: &models.MitreMetricCVSS31{
					Cvss3: models.Cvss3{
						VectorString: m.CVSSv31.VectorString,
						BaseScore:    m.CVSSv31.BaseScore,
						BaseSeverity: m.CVSSv31.BaseSeverity,
					},
				},
			})
		}
		if m.CVSSv40 != nil {
			ms = append(ms, models.MitreMetric{
				Format: func() string {
					if m.Format != nil {
						return *m.Format
					}
					return "CVSS"
				}(),
				Scenarios: sc,
				CVSSv40: &models.MitreMetricCVSS40{
					Cvss40: models.Cvss40{
						VectorString:          m.CVSSv40.VectorString,
						BaseScore:             m.CVSSv40.BaseScore,
						BaseSeverity:          m.CVSSv40.BaseSeverity,
						ThreatScore:           m.CVSSv40.ThreatScore,
						ThreatSeverity:        m.CVSSv40.ThreatSeverity,
						EnvironmentalScore:    m.CVSSv40.EnvironmentalScore,
						EnvironmentalSeverity: m.CVSSv40.EnvironmentalSeverity,
					},
				},
			})
		}
		if m.Other != nil {
			switch m.Other.Type {
			case "kev":
				var v kev
				if err := json.Unmarshal(m.Other.Content, &v); err != nil {
					log.Warnf("%v is not expected kev type", m.Other.Content)
					break
				}
				ms = append(ms, models.MitreMetric{
					Format: func() string {
						if m.Format != nil {
							return *m.Format
						}
						return "KEV"
					}(),
					Scenarios: sc,
					KEV: &models.MitreMetricKEV{
						DateAdded: func() time.Time {
							if t := parseTime(layouts, &v.DateAdded); t != nil {
								return *t
							}
							return time.Date(1000, time.January, 1, 0, 0, 0, 0, time.UTC)
						}(),
						Reference: v.Reference,
					},
				})
			case "ssvc":
				var v ssvc
				if err := json.Unmarshal(m.Other.Content, &v); err != nil {
					log.Warnf("%v is not expected ssvc type", m.Other.Content)
					break
				}
				s := models.MitreMetricSSVC{
					Role:    v.Role,
					Version: v.Version,
					Timestamp: func() time.Time {
						if t := parseTime(layouts, &v.Timestamp); t != nil {
							return *t
						}
						return time.Date(1000, time.January, 1, 0, 0, 0, 0, time.UTC)
					}(),
				}
				for _, o := range v.Options {
					if o.Exploitation != nil {
						s.Exploitation = o.Exploitation
					}
					if o.Automatable != nil {
						s.Automatable = o.Automatable
					}
					if o.TechnicalImpact != nil {
						s.TechnicalImpact = o.TechnicalImpact
					}
				}

				ms = append(ms, models.MitreMetric{
					Format: func() string {
						if m.Format != nil {
							return *m.Format
						}
						return "SSVC"
					}(),
					Scenarios: sc,
					SSVC:      &s,
				})
			default:
				ms = append(ms, models.MitreMetric{
					Format: func() string {
						if m.Format != nil {
							return *m.Format
						}
						return "other"
					}(),
					Scenarios: sc,
					Other: &models.MitreMetricOther{
						Type:    m.Other.Type,
						Content: string(m.Other.Content),
					},
				})
			}
		}
	}
	return ms
}

func convertWorkaround(descriptions []description) []models.MitreWorkaround {
	ds := make([]models.MitreWorkaround, 0, len(descriptions))
	for _, d := range descriptions {
		ms := make([]models.MitreWorkaroundSupportingMedia, 0, len(d.SupportingMedia))
		for _, m := range d.SupportingMedia {
			ms = append(ms, models.MitreWorkaroundSupportingMedia{
				Type:   m.Type,
				Base64: m.Base64,
				Value:  m.Value,
			})
		}
		ds = append(ds, models.MitreWorkaround{
			Lang:            d.Lang,
			Value:           d.Value,
			SupportingMedia: ms,
		})
	}
	return ds
}

func convertSolution(descriptions []description) []models.MitreSolution {
	ds := make([]models.MitreSolution, 0, len(descriptions))
	for _, d := range descriptions {
		ms := make([]models.MitreSolutionSupportingMedia, 0, len(d.SupportingMedia))
		for _, m := range d.SupportingMedia {
			ms = append(ms, models.MitreSolutionSupportingMedia{
				Type:   m.Type,
				Base64: m.Base64,
				Value:  m.Value,
			})
		}
		ds = append(ds, models.MitreSolution{
			Lang:            d.Lang,
			Value:           d.Value,
			SupportingMedia: ms,
		})
	}
	return ds
}

func convertExploit(descriptions []description) []models.MitreExploit {
	ds := make([]models.MitreExploit, 0, len(descriptions))
	for _, d := range descriptions {
		ms := make([]models.MitreExploitSupportingMedia, 0, len(d.SupportingMedia))
		for _, m := range d.SupportingMedia {
			ms = append(ms, models.MitreExploitSupportingMedia{
				Type:   m.Type,
				Base64: m.Base64,
				Value:  m.Value,
			})
		}
		ds = append(ds, models.MitreExploit{
			Lang:            d.Lang,
			Value:           d.Value,
			SupportingMedia: ms,
		})
	}
	return ds
}

func convertConfiguration(descriptions []description) []models.MitreConfiguration {
	ds := make([]models.MitreConfiguration, 0, len(descriptions))
	for _, d := range descriptions {
		ms := make([]models.MitreConfigurationSupportingMedia, 0, len(d.SupportingMedia))
		for _, m := range d.SupportingMedia {
			ms = append(ms, models.MitreConfigurationSupportingMedia{
				Type:   m.Type,
				Base64: m.Base64,
				Value:  m.Value,
			})
		}
		ds = append(ds, models.MitreConfiguration{
			Lang:            d.Lang,
			Value:           d.Value,
			SupportingMedia: ms,
		})
	}
	return ds
}

func covnertReference(references []reference) []models.MitreReference {
	rs := make([]models.MitreReference, 0, len(references))
	for _, r := range references {
		rs = append(rs, models.MitreReference{
			Reference: models.Reference{
				Link: r.URL,
				Tags: strings.Join(r.Tags, ","),
				Name: func() string {
					if r.Name == nil {
						return ""
					}
					return *r.Name
				}(),
			},
		})
	}
	return rs
}

func convertTimeline(timeline timeline) []models.MitreTimeline {
	ts := make([]models.MitreTimeline, 0, len(timeline))
	for _, t := range timeline {
		ts = append(ts, models.MitreTimeline{
			Time: func() time.Time {
				if t := parseTime(layouts, &t.Time); t != nil {
					return *t
				}
				return time.Date(1000, time.January, 1, 0, 0, 0, 0, time.UTC)
			}(),
			Lang:  t.Lang,
			Value: t.Value,
		})
	}
	return ts
}

func convertCredit(credits credits) []models.MitreCredit {
	cs := make([]models.MitreCredit, 0, len(credits))
	for _, c := range credits {
		cs = append(cs, models.MitreCredit{
			Type:  c.Type,
			Lang:  c.Lang,
			User:  c.User,
			Value: c.Value,
		})
	}
	return cs
}

func convertTag(tags []string) []models.MitreTag {
	ts := make([]models.MitreTag, 0, len(tags))
	for _, t := range tags {
		ts = append(ts, models.MitreTag{
			Tag: t,
		})
	}
	return ts
}

func convertTaxonomyMappings(taxonomyMappings taxonomyMappings) []models.MitreTaxonomyMapping {
	ts := make([]models.MitreTaxonomyMapping, 0, len(taxonomyMappings))
	for _, t := range taxonomyMappings {
		rs := make([]models.MitreTaxonomyRelation, 0, len(t.TaxonomyRelations))
		for _, r := range t.TaxonomyRelations {
			rs = append(rs, models.MitreTaxonomyRelation{
				TaxonomyID:        r.TaxonomyID,
				RelationshipName:  r.RelationshipName,
				RelationshipValue: r.RelationshipValue,
			})
		}
		ts = append(ts, models.MitreTaxonomyMapping{
			TaxonomyVersion:   t.TaxonomyVersion,
			TaxonomyName:      t.TaxonomyName,
			TaxonomyRelations: rs,
		})
	}
	return ts
}
