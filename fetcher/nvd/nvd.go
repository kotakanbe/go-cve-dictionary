package nvd

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/hashicorp/go-version"
	"github.com/spf13/viper"
	"golang.org/x/exp/slices"
	"golang.org/x/xerrors"

	"github.com/vulsio/go-cve-dictionary/fetcher"
	"github.com/vulsio/go-cve-dictionary/log"
	"github.com/vulsio/go-cve-dictionary/models"
	"github.com/vulsio/go-cve-dictionary/util"
)

const repositoryURL = "https://github.com/vulsio/vuls-data-raw-nvd-api-cve/archive/refs/heads/main.tar.gz"

// Fetch Fetch CVE vulnerability information from NVD
func Fetch() (string, error) {
	d := util.CacheDir()

	if err := os.RemoveAll(d); err != nil {
		return "", xerrors.Errorf("Failed to remove %s. err: %w", d, err)
	}

	bs, err := fetcher.FetchFeedFile(repositoryURL, false)
	if err != nil {
		return "", xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	gr, err := gzip.NewReader(bytes.NewReader(bs))
	if err != nil {
		return "", xerrors.Errorf("Failed to create gzip reader. err: %w", err)
	}
	defer gr.Close()

	tr := tar.NewReader(gr)
	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return "", xerrors.Errorf("Failed to next tar reader. err: %w", err)
		}

		if hdr.FileInfo().IsDir() {
			continue
		}

		if !strings.HasPrefix(filepath.Base(hdr.Name), "CVE-") {
			continue
		}

		if err := func() error {
			ss := strings.Split(filepath.Base(hdr.Name), "-")
			if len(ss) != 3 {
				return xerrors.Errorf("Failed to parse year. err: invalid ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}.json", filepath.Base(hdr.Name))
			}
			if _, err := time.Parse("2006", ss[1]); err != nil {
				return xerrors.Errorf("Failed to parse year. err: invalid ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}.json", filepath.Base(hdr.Name))
			}

			if err := os.MkdirAll(filepath.Join(d, ss[1]), os.ModePerm); err != nil {
				return xerrors.Errorf("Failed to mkdir %s. err: %w", filepath.Join(d, ss[1]), err)
			}

			f, err := os.Create(filepath.Join(d, ss[1], filepath.Base(hdr.Name)))
			if err != nil {
				return xerrors.Errorf("Failed to create %s. err: %w", filepath.Join(d, ss[1], filepath.Base(hdr.Name)), err)
			}
			defer f.Close()

			if _, err := io.Copy(f, tr); err != nil {
				return xerrors.Errorf("Failed to copy %s to %s. err: %w", hdr.Name, filepath.Join(d, ss[1], filepath.Base(hdr.Name)), err)
			}

			return nil
		}(); err != nil {
			return "", xerrors.Errorf("Failed to extract %s. err: %w", hdr.Name, err)
		}
	}

	return d, nil
}

// Convert convert <cacheDir>/<year>/CVE-<year>-\d{4,}.json to []models.Nvd
func Convert(cacheDir, year string) ([]models.Nvd, error) {
	var ps []string
	if err := filepath.WalkDir(cacheDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}

		if strings.HasPrefix(filepath.Base(path), fmt.Sprintf("CVE-%s-", year)) {
			ps = append(ps, path)
		}

		return nil
	}); err != nil {
		return nil, xerrors.Errorf("Failed to walk %s. err: %w", cacheDir, err)
	}

	reqChan := make(chan string, len(ps))
	resChan := make(chan *models.Nvd, len(ps))
	errChan := make(chan error, len(ps))
	defer close(reqChan)
	defer close(resChan)
	defer close(errChan)

	go func() {
		for _, p := range ps {
			reqChan <- p
		}
	}()

	concurrency := runtime.NumCPU() + 2
	tasks := util.GenWorkers(concurrency)
	for range ps {
		tasks <- func() {
			req := <-reqChan
			cve, err := convertToModel(req)
			if err != nil {
				errChan <- err
				return
			}
			resChan <- cve
		}
	}

	cves := []models.Nvd{}
	errs := []error{}
	timeout := time.After(10 * 60 * time.Second)
	for range ps {
		select {
		case res := <-resChan:
			if res != nil {
				cves = append(cves, *res)
			}
		case err := <-errChan:
			errs = append(errs, err)
		case <-timeout:
			return nil, fmt.Errorf("Timeout Fetching")
		}
	}
	if 0 < len(errs) {
		return nil, xerrors.Errorf("%w", errs)
	}
	return cves, nil
}

// convertToModel converts Nvd JSON to model structure.
func convertToModel(cvePath string) (*models.Nvd, error) {
	f, err := os.Open(cvePath)
	if err != nil {
		return nil, xerrors.Errorf("Failed to open %s. err: %w", cvePath, err)
	}
	defer f.Close()

	var item cve
	if err := json.NewDecoder(f).Decode(&item); err != nil {
		return nil, xerrors.Errorf("Failed to decode %s. err: %w", cvePath, err)
	}

	// Description
	descs := []models.NvdDescription{}
	for _, desc := range item.Descriptions {
		if strings.Contains(desc.Value, "** REJECT **") {
			return nil, nil
		}
		descs = append(descs, models.NvdDescription{
			Lang:  desc.Lang,
			Value: desc.Value,
		})
	}

	//References
	refs := []models.NvdReference{}
	for _, r := range item.References {
		refs = append(refs, models.NvdReference{
			Reference: models.Reference{
				Link:   r.URL,
				Name:   r.URL,
				Source: r.Source,
				Tags:   strings.Join(r.Tags, ","),
			},
		})
	}

	// Certs
	certs := []models.NvdCert{}
	for _, ref := range item.References {
		if !strings.HasPrefix(ref.URL, "http") {
			continue
		}
		if strings.Contains(ref.URL, "us-cert") {
			ss := strings.Split(ref.URL, "/")
			title := fmt.Sprintf("US-CERT-%s", ss[len(ss)-1])
			certs = append(certs, models.NvdCert{
				Cert: models.Cert{
					Link:  ref.URL,
					Title: title,
				},
			})
		}
	}

	// Cwes
	cwes := []models.NvdCwe{}
	for _, weak := range item.Weaknesses {
		for _, desc := range weak.Description {
			if !slices.ContainsFunc(cwes, func(e models.NvdCwe) bool {
				return e.Source == weak.Source && e.Type == weak.Type && e.CweID == desc.Value
			}) {
				cwes = append(cwes, models.NvdCwe{
					Source: weak.Source,
					Type:   weak.Type,
					CweID:  desc.Value,
				})
			}
		}
	}

	full := viper.GetBool("full")
	cpes := []models.NvdCpe{}
	for _, conf := range item.Configurations {
		if conf.Negate {
			continue
		}

		var (
			nodeCpes    []models.NvdCpe
			nodeEnvCpes []models.NvdEnvCpe
		)
		for _, node := range conf.Nodes {
			if node.Negate {
				continue
			}

			for _, cpe := range node.CPEMatch {
				if cpe.Vulnerable {
					cpeBase, err := fetcher.ParseCpeURI(cpe.Criteria)
					if err != nil {
						log.Infof("Failed to parse CpeURI %s: %s", cpe.Criteria, err)
						continue
					}
					cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
					cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
					cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
					cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
					nodeCpes = append(nodeCpes, models.NvdCpe{
						CpeBase: *cpeBase,
						EnvCpes: []models.NvdEnvCpe{},
					})
					if !checkIfVersionParsable(cpeBase) {
						return nil, fmt.Errorf("Version parse err. Please add a issue on [GitHub](https://github.com/vulsio/go-cve-dictionary/issues/new). Title: %s, Content: %v", item.ID, item)
					}
				} else {
					if !full || conf.Operator != "AND" {
						continue
					}
					cpeBase, err := fetcher.ParseCpeURI(cpe.Criteria)
					if err != nil {
						log.Infof("Failed to parse CpeURI %s: %s", cpe.Criteria, err)
						continue
					}
					cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
					cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
					cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
					cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
					nodeEnvCpes = append(nodeEnvCpes, models.NvdEnvCpe{
						CpeBase: *cpeBase,
					})
					if !checkIfVersionParsable(cpeBase) {
						return nil, fmt.Errorf("Version parse err. Please add a issue on [GitHub](https://github.com/vulsio/go-cve-dictionary/issues/new). Title: %s, Content: %v", item.ID, item)
					}
				}
			}
		}
		for _, nodeCpe := range nodeCpes {
			nodeCpe.EnvCpes = append(nodeCpe.EnvCpes, nodeEnvCpes...)
			cpes = append(cpes, nodeCpe)
		}
	}

	c2 := make([]models.NvdCvss2Extra, 0, len(item.Metrics.CVSSMetricV2))
	for _, v2 := range item.Metrics.CVSSMetricV2 {
		c2 = append(c2, models.NvdCvss2Extra{
			Source: v2.Source,
			Type:   v2.Type,
			Cvss2: models.Cvss2{
				VectorString:          v2.CvssData.VectorString,
				AccessVector:          v2.CvssData.AccessVector,
				AccessComplexity:      v2.CvssData.AccessComplexity,
				Authentication:        v2.CvssData.Authentication,
				ConfidentialityImpact: v2.CvssData.ConfidentialityImpact,
				IntegrityImpact:       v2.CvssData.IntegrityImpact,
				AvailabilityImpact:    v2.CvssData.AvailabilityImpact,
				BaseScore:             v2.CvssData.BaseScore,
				Severity:              v2.BaseSeverity,
			},
			ExploitabilityScore:     v2.ExploitabilityScore,
			ImpactScore:             v2.ImpactScore,
			ObtainAllPrivilege:      v2.ObtainAllPrivilege,
			ObtainUserPrivilege:     v2.ObtainUserPrivilege,
			ObtainOtherPrivilege:    v2.ObtainOtherPrivilege,
			UserInteractionRequired: v2.UserInteractionRequired,
		})
	}

	c3 := make([]models.NvdCvss3, 0, len(item.Metrics.CVSSMetricV30)+len(item.Metrics.CVSSMetricV31))
	for _, v30 := range item.Metrics.CVSSMetricV30 {
		c3 = append(c3, models.NvdCvss3{
			Source: v30.Source,
			Type:   v30.Type,
			Cvss3: models.Cvss3{
				VectorString:          v30.CVSSData.VectorString,
				AttackVector:          v30.CVSSData.AttackVector,
				AttackComplexity:      v30.CVSSData.AttackComplexity,
				PrivilegesRequired:    v30.CVSSData.PrivilegesRequired,
				UserInteraction:       v30.CVSSData.UserInteraction,
				Scope:                 v30.CVSSData.Scope,
				ConfidentialityImpact: v30.CVSSData.ConfidentialityImpact,
				IntegrityImpact:       v30.CVSSData.IntegrityImpact,
				AvailabilityImpact:    v30.CVSSData.AvailabilityImpact,
				BaseScore:             v30.CVSSData.BaseScore,
				BaseSeverity:          v30.CVSSData.BaseSeverity,
				ExploitabilityScore:   v30.ExploitabilityScore,
				ImpactScore:           v30.ImpactScore,
			},
		})
	}
	for _, v31 := range item.Metrics.CVSSMetricV31 {
		c3 = append(c3, models.NvdCvss3{
			Source: v31.Source,
			Type:   v31.Type,
			Cvss3: models.Cvss3{
				VectorString:          v31.CVSSData.VectorString,
				AttackVector:          v31.CVSSData.AttackVector,
				AttackComplexity:      v31.CVSSData.AttackComplexity,
				PrivilegesRequired:    v31.CVSSData.PrivilegesRequired,
				UserInteraction:       v31.CVSSData.UserInteraction,
				Scope:                 v31.CVSSData.Scope,
				ConfidentialityImpact: v31.CVSSData.ConfidentialityImpact,
				IntegrityImpact:       v31.CVSSData.IntegrityImpact,
				AvailabilityImpact:    v31.CVSSData.AvailabilityImpact,
				BaseScore:             v31.CVSSData.BaseScore,
				BaseSeverity:          v31.CVSSData.BaseSeverity,
				ExploitabilityScore: func() float64 {
					if v31.ExploitabilityScore != nil {
						return *v31.ExploitabilityScore
					}
					return 0
				}(),
				ImpactScore: func() float64 {
					if v31.ImpactScore != nil {
						return *v31.ImpactScore
					}
					return 0
				}(),
			},
		})
	}

	publish, err := parseNvdTime(item.Published)
	if err != nil {
		return nil, xerrors.Errorf("Failed to parse NVD Time. err: %w", err)
	}
	modified, err := parseNvdTime(item.LastModified)
	if err != nil {
		return nil, xerrors.Errorf("Failed to parse NVD Time. err: %w", err)
	}

	return &models.Nvd{
		CveID:            item.ID,
		Descriptions:     descs,
		Cvss2:            c2,
		Cvss3:            c3,
		Cwes:             cwes,
		Cpes:             cpes,
		References:       refs,
		Certs:            certs,
		PublishedDate:    publish,
		LastModifiedDate: modified,
	}, nil
}

func checkIfVersionParsable(cpeBase *models.CpeBase) bool {
	if cpeBase.Version != "ANY" && cpeBase.Version != "NA" {
		vers := []string{cpeBase.VersionStartExcluding,
			cpeBase.VersionStartIncluding,
			cpeBase.VersionEndIncluding,
			cpeBase.VersionEndExcluding}
		for _, v := range vers {
			if v == "" {
				continue
			}
			v := strings.Replace(v, `\`, "", -1)
			if _, err := version.NewVersion(v); err != nil {
				return false
			}
		}
	}
	return true
}

func parseNvdTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04:05.000"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, xerrors.Errorf("Failed to parse time, time: %s, err: %w", strtime, err)
	}
	return
}
