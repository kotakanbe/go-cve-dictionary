package fortinet

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/knqyf263/go-cpe/common"
	"github.com/knqyf263/go-cpe/naming"
	"golang.org/x/exp/maps"
	"golang.org/x/xerrors"

	"github.com/vulsio/go-cve-dictionary/fetcher"
	"github.com/vulsio/go-cve-dictionary/log"
	"github.com/vulsio/go-cve-dictionary/models"
)

// FetchConvert Fetch CVE vulnerability information from Fortinet
func FetchConvert() ([]models.Fortinet, error) {
	bs, err := fetcher.FetchFeedFile("https://github.com/vulsio/vuls-data-raw-fortinet/archive/refs/heads/main.zip", false)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch vulsio/vuls-data-raw-fortinet. err: %w", err)
	}

	r, err := zip.NewReader(bytes.NewReader(bs), int64(len(bs)))
	if err != nil {
		return nil, xerrors.Errorf("Failed to create zip reader. err: %w", err)
	}

	var advs []models.Fortinet
	for _, zf := range r.File {
		if zf.FileInfo().IsDir() {
			continue
		}

		as, err := func() ([]models.Fortinet, error) {
			f, err := zf.Open()
			if err != nil {
				return nil, xerrors.Errorf("Failed to open. err: %w", err)
			}
			defer f.Close()

			var a advisory
			if err := json.NewDecoder(f).Decode(&a); err != nil {
				return nil, xerrors.Errorf("Failed to decode json. err: %w", err)
			}

			converted, err := convert(a)
			if err != nil {
				return nil, xerrors.Errorf("Failed to convert advisory. err: %w", err)
			}

			return converted, nil
		}()
		if err != nil {
			return nil, xerrors.Errorf("Failed to convert %s. err: %w", zf.Name, err)
		}

		advs = append(advs, as...)
	}

	return advs, nil
}

func convert(a advisory) ([]models.Fortinet, error) {
	converted := []models.Fortinet{}
	for _, v := range a.Vulnerabilities {
		if v.CVE == "" {
			continue
		}

		cs := models.Fortinet{
			AdvisoryID:       a.ID,
			CveID:            v.CVE,
			Title:            a.Title,
			Summary:          a.Summary,
			Descriptions:     a.Description,
			PublishedDate:    a.Published,
			LastModifiedDate: a.Updated,
			AdvisoryURL:      a.AdvisoryURL,
		}

		for _, d := range v.Definitions {
			m := map[models.FortinetCpe]struct{}{}
			for _, c := range d.Configurations {
				cpes, err := cpeWalk(c)
				if err != nil {
					return nil, xerrors.Errorf("Failed to cpe walk. err: %w", err)
				}
				for _, cpe := range cpes {
					m[cpe] = struct{}{}
				}
			}
			cs.Cpes = maps.Keys(m)

			if d.CVSSv3 != nil {
				parsed := parseCvss3VectorStr(d.CVSSv3.Vector)
				cs.Cvss3 = models.FortinetCvss3{
					Cvss3: models.Cvss3{
						VectorString:          d.CVSSv3.Vector,
						AttackVector:          parsed.AttackVector,
						AttackComplexity:      parsed.AttackComplexity,
						PrivilegesRequired:    parsed.PrivilegesRequired,
						UserInteraction:       parsed.UserInteraction,
						Scope:                 parsed.Scope,
						ConfidentialityImpact: parsed.ConfidentialityImpact,
						IntegrityImpact:       parsed.IntegrityImpact,
						AvailabilityImpact:    parsed.AvailabilityImpact,
					},
				}
				if d.CVSSv3.BaseScore != nil {
					cs.Cvss3.Cvss3.BaseScore = *d.CVSSv3.BaseScore
				}
			}

			for _, cwe := range d.CWE {
				cs.Cwes = append(cs.Cwes, models.FortinetCwe{
					CweID: cwe,
				})
			}
		}

		for _, r := range a.References {
			cs.References = append(cs.References, models.FortinetReference{
				Reference: models.Reference{
					Name: r.Description,
					Link: r.URL,
				},
			})
		}

		converted = append(converted, cs)
	}
	return converted, nil
}

func cpeWalk(conf configuration) ([]models.FortinetCpe, error) {
	cpes := []models.FortinetCpe{}

	for _, n := range conf.Nodes {
		if strings.HasSuffix(n.Description, ":") || ((n.Affected.Eqaul != nil && *n.Affected.Eqaul == "") && (n.Affected.GreaterThan != nil && *n.Affected.GreaterThan == "") && (n.Affected.GreaterEqaul != nil && *n.Affected.GreaterEqaul == "") && (n.Affected.LessThan != nil && *n.Affected.LessThan == "") && (n.Affected.LessEqual != nil && *n.Affected.LessEqual == "")) {
			continue
		}

		wfn, err := naming.UnbindFS(n.CPE)
		if err != nil {
			return nil, xerrors.Errorf("Failed to unbind a formatted string to WFN. err: %w", err)
		}

		if n.Affected.Eqaul != nil {
			// n.Affected.Eqaul: 4.2.0, 5.0.0:beta1, ANY, NA
			for i, v := range strings.Split(*n.Affected.Eqaul, ":") {
				switch i {
				case 0:
					switch v {
					case "ANY", "NA":
						lv, err := common.NewLogicalValue(v)
						if err != nil {
							return nil, xerrors.Errorf("Failed to new Logicalvalue. err: %w", err)
						}
						if err := wfn.Set(common.AttributeVersion, lv); err != nil {
							return nil, xerrors.Errorf("Failed to set version to WFN. err: %w", err)
						}
					default:
						if err := wfn.Set(common.AttributeVersion, strings.NewReplacer(".", "\\.", "-", "\\-").Replace(v)); err != nil {
							return nil, xerrors.Errorf("Failed to set version to WFN. err: %w", err)
						}
					}
				case 1:
					switch v {
					case "ANY", "NA":
						lv, err := common.NewLogicalValue(v)
						if err != nil {
							return nil, xerrors.Errorf("Failed to new Logicalvalue. err: %w", err)
						}
						if err := wfn.Set(common.AttributeUpdate, lv); err != nil {
							return nil, xerrors.Errorf("Failed to set update to WFN. err: %w", err)
						}
					default:
						if err := wfn.Set(common.AttributeUpdate, v); err != nil {
							return nil, xerrors.Errorf("Failed to set update to WFN. err: %w", err)
						}
					}
				}
			}
		}

		cpeBase := models.CpeBase{
			URI:             naming.BindToURI(wfn),
			FormattedString: naming.BindToFS(wfn),
			WellFormedName:  wfn.String(),
			CpeWFN: models.CpeWFN{
				Part:            fmt.Sprintf("%s", wfn.Get(common.AttributePart)),
				Vendor:          fmt.Sprintf("%s", wfn.Get(common.AttributeVendor)),
				Product:         fmt.Sprintf("%s", wfn.Get(common.AttributeProduct)),
				Version:         fmt.Sprintf("%s", wfn.Get(common.AttributeVersion)),
				Update:          fmt.Sprintf("%s", wfn.Get(common.AttributeUpdate)),
				Edition:         fmt.Sprintf("%s", wfn.Get(common.AttributeEdition)),
				Language:        fmt.Sprintf("%s", wfn.Get(common.AttributeLanguage)),
				SoftwareEdition: fmt.Sprintf("%s", wfn.Get(common.AttributeSwEdition)),
				TargetSW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetSw)),
				TargetHW:        fmt.Sprintf("%s", wfn.Get(common.AttributeTargetHw)),
				Other:           fmt.Sprintf("%s", wfn.Get(common.AttributeOther)),
			},
		}

		if n.Affected.GreaterThan != nil {
			cpeBase.VersionStartExcluding = *n.Affected.GreaterThan
		}
		if n.Affected.GreaterEqaul != nil {
			cpeBase.VersionStartIncluding = *n.Affected.GreaterEqaul
		}
		if n.Affected.LessThan != nil {
			cpeBase.VersionEndExcluding = *n.Affected.LessThan
		}
		if n.Affected.LessEqual != nil {
			cpeBase.VersionEndIncluding = *n.Affected.LessEqual
		}

		cpes = append(cpes, models.FortinetCpe{
			CpeBase: cpeBase,
		})
	}

	if conf.Children != nil {
		cs, err := cpeWalk(*conf.Children)
		if err != nil {
			return nil, xerrors.Errorf("Failed to cpewalk. err: %w", err)
		}
		cpes = append(cpes, cs...)
	}

	return cpes, nil
}

func parseCvss3VectorStr(vector string) models.Cvss3 {
	cvss := models.Cvss3{VectorString: vector}
	for _, s := range strings.Split(strings.TrimPrefix(vector, "CVSS:3.1/"), "/") {
		m, v, ok := strings.Cut(s, ":")
		if !ok {
			continue
		}
		switch m {
		case "AV":
			switch v {
			case "N":
				cvss.AttackVector = "NETWORK"
			case "A":
				cvss.AttackVector = "ADJACENT_NETWORK"
			case "L":
				cvss.AttackVector = "LOCAL"
			case "P":
				cvss.AttackVector = "PHYSICAL"
			default:
				log.Warnf("%s is unknown Attack Vector", v)
			}
		case "AC":
			switch v {
			case "L":
				cvss.AttackComplexity = "LOW"
			case "H":
				cvss.AttackComplexity = "HIGH"
			default:
				log.Warnf("%s is unknown Attack Complexity", v)
			}
		case "PR":
			switch v {
			case "N":
				cvss.PrivilegesRequired = "NONE"
			case "L":
				cvss.PrivilegesRequired = "LOW"
			case "H":
				cvss.PrivilegesRequired = "HIGH"
			default:
				log.Warnf("%s is unknown Privileges Required", v)
			}
		case "UI":
			switch v {
			case "N":
				cvss.UserInteraction = "NONE"
			case "R":
				cvss.UserInteraction = "REQUIRED"
			default:
				log.Warnf("%s is unknown User Interaction", v)
			}
		case "S":
			switch v {
			case "U":
				cvss.Scope = "UNCHANGED"
			case "C":
				cvss.Scope = "CHANGED"
			default:
				log.Warnf("%s is unknown Scope", v)
			}
		case "C":
			switch v {
			case "N":
				cvss.ConfidentialityImpact = "NONE"
			case "L":
				cvss.ConfidentialityImpact = "LOW"
			case "H":
				cvss.ConfidentialityImpact = "HIGH"
			default:
				log.Warnf("%s is unknown Confidentiality", v)
			}
		case "I":
			switch v {
			case "N":
				cvss.IntegrityImpact = "NONE"
			case "L":
				cvss.IntegrityImpact = "LOW"
			case "H":
				cvss.IntegrityImpact = "HIGH"
			default:
				log.Warnf("%s is unknown Integrity", v)
			}
		case "A":
			switch v {
			case "N":
				cvss.AvailabilityImpact = "NONE"
			case "L":
				cvss.AvailabilityImpact = "LOW"
			case "H":
				cvss.AvailabilityImpact = "HIGH"
			default:
				log.Warnf("%s is unknown Availability", v)
			}
		case "E", "RL", "RC", "CR", "IR", "AR", "MAV", "MAC", "MPR", "MUI", "MS", "MC", "MI", "MA":
		default:
			log.Warnf("%s is unknown metrics", m)
		}
	}

	return cvss
}
